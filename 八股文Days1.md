# 八股文Days1

## 1. 介绍一下TCP/IP模型和OSI模型的区别

OSI模型：

+ 物理层；
+ 数据链路层；
+ 网络层；
+ 传输层；
+ 表示层；
+ 会话层；
+ 应用层；

TCP/IP模型：

+ 网络接口层；
  + 主要负责物理传输媒介的传输，并提供错误检测和纠正的功能；
+ 网络层；
  + 主要负责数据包的路由和转发，选择最佳路径将数据从源主机传输到目标主机；
  + IP；
+ 传输层；
  + 主要负责端到端的数据传输；
  + TCP；
  + UDP；
+ 应用层；
  + 为网络上的各种应用程序提供服务；
  + HTTP；
  + SMTP；
  + FTP；

虽然OSI模型在理论上更全面，但在实际网络通信中，TCP/IP模型更为实用。

## 2. 从输入 URL 到页面展示到底发生了什么？

1. 浏览器中输入网址，浏览器开始解析URL；
2. 查看浏览器缓存是否有之前的信息；
3. DNS域名解析，查找到URL对应的IP地址；
4. TCP三次连接；
5. 发送HTTP请求；
6. 服务器解析HTTP请求，并返回相应的资源；
7. TCP四次挥手；
8. 浏览器渲染结果；

## 3. 扩展

### 3.1 DNS解析

过程：

+ 本地浏览器缓存；
+ 本地Host库；
+ 路由器缓存；
+ 本地DNS服务器；
+ 根DNS服务器；

DNS属于应用层协议。

### 3.2 TCP三次连接

+ 准备工作：
  + 客户端创建socket，在内核中会创建相关的数据结构。
  + 服务器也会创建socket，调用bind绑定一个端口，然后调用listen监听客户端连接。listen会创建半连接队列和全连接队列。

+ 三次握手：
  + 第一次握手：
    + 客户端调用connect发起连接，会发一个SYN给服务器，在这里如果之前没有bind一个端口，操作系统会自己选择一个可用的端口，并且在这里需要注意，如果客户端端口剩余不多的话，这个过程可能会比较耗费CPU。
    + 第一次握手丢失：tcp_syn_retries设置重传的次数，每次时间翻倍。达到tcp_syn_retries设置重传的次数就会断开连接。
  + 第二次握手：
    + 服务器收到SYN后，回一个SYN + ACK，将客户连接加入到半连接队列中。在这里可能会受到SYN的泛洪攻击，将服务器的半连接队列撑满，我们可以通过开启syncookies机制，让其不走半连接队列建立连接。
    + 第二次握手丢失：客户端会重传SYN，次数由tcp_syn_retries决定；服务器也会重传SYN + ACK，次数由tcp_synack_retries决定。
  + 第三次握手：
    + 客户端收到服务器的SYN + ACK后，回一个ACK，然后可以带上需要发送的数据。三次握手连接好的连接会从半连接队列中移动到全连接队列中，accept从全连接队列中取。
    + 第三次握手丢失：服务器重传SYN + ACK，次数由tcp_synack_retries决定。
+ 为什么要三次？
  + 序号的完整性。
  + 历史连接问题，防止之前因为网络延迟等原因的数据包到达服务器从而影响连接的可靠性。

+ 抵御泛洪攻击的方法：
  + 增大 TCP 半连接队列：
    + 增大 net.ipv4.tcp_max_syn_backlog；
    + 增大 listen() 函数中的 backlog；
    + 增大net.core.somaxconn；
  + 开启 net.ipv4.tcp_syncookies：
  + 减少 SYN+ACK 重传次数；

### 3.3 TCP四次挥手

+ 第一次挥手：
  + 主动方发出FIN报文；
  + 第一次挥手丢失：
    + 重传，次数由tcp_orphan_retries决定，时间倍数增长；
+ 第二次挥手：
  + 被动方回一个ACK；
  + 第二次挥手丢失：
    + 重传，次数由tcp_orphan_retries决定，时间倍数增长；
+ 第三次挥手：
  + 被动方回一个FIN；
  + 第三次挥手丢失：
    + 重传，次数由tcp_orphan_retries决定，时间倍数增长；
+ 第四次挥手：
  + 主动方回一个ACK，并等待2MSL（TIME_WAIT）；
  + 第四次挥手丢失：
    + 重传，次数由tcp_orphan_retries决定，时间倍数增长；



**什么时候可以变为四次？**

第二次和第三次挥手合并，也就是被动方没有数据需要处理。



**为什么需要TIME_WAIT？**

+ 防止历史连接中的数据，被后面相同四元组的连接错误的接收；
+ 保证「被动关闭连接」的一方，能被正确的关闭；



**TIME_WAIT 过多有什么危害？**

+ 占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；
+ 占用端口资源；